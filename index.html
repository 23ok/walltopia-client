<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <title>Walltopia Client</title>
  <style>
    body { margin: 0; background: #000; color: #fff; display: flex; flex-direction: column; align-items: center; }
    #auth { margin: 16px; }
    #auth input { margin: 4px; padding: 6px; }
    #game-container { position: relative; }
    #game { border: 1px solid #555; background: #222; }
    #status { margin: 8px; }
  </style>
</head>
<body>
  <div id="auth">
    <h2>Login / Registro</h2>
    <input id="email" type="email" placeholder="E-mail" />
    <input id="password" type="password" placeholder="Senha" />
    <input id="characterName" type="text" placeholder="Nome do Personagem" />
    <button id="btn-register">Registrar</button>
    <button id="btn-login">Entrar</button>
    <div id="auth-status"></div>
  </div>

  <h1>Walltopia Client</h1>
  <p id="status">Aguardando autenticação...</p>
  <div id="game-container" style="display:none;">
    <canvas id="game" width="1800" height="600"></canvas>
  </div>

  <script src="https://cdn.socket.io/4.6.1/socket.io.min.js"></script>
  <script>
    const SERVER_URL = 'https://0803cfd3-ab2a-4b96-bf35-eb788a29f988-00-2jhigdrm8gnnu.worf.replit.dev';
    let socket, token;

    const authStatus = document.getElementById('auth-status');
    document.getElementById('btn-register').onclick = async () => {
      const email = emailInput.value.trim();
      const password = passwordInput.value;
      const name = characterName.value.trim();
      if (!email || !password || !name) return authStatus.textContent = 'Preencha todos os campos.';
      const res = await fetch(SERVER_URL + '/register', {
        method: 'POST', headers: {'Content-Type':'application/json'},
        body: JSON.stringify({email, password, characterName:name})
      });
      const data = await res.json();
      authStatus.textContent = data.error || data.message;
    };
    document.getElementById('btn-login').onclick = async () => {
      const email = emailInput.value.trim();
      const password = passwordInput.value;
      if (!email || !password) return authStatus.textContent = 'E-mail e senha são obrigatórios.';
      const res = await fetch(SERVER_URL + '/login', {
        method: 'POST', headers: {'Content-Type':'application/json'},
        body: JSON.stringify({email, password})
      });
      const data = await res.json();
      if (data.error) return authStatus.textContent = data.error;
      token = data.token;
      authStatus.textContent = 'Autenticado!';
      startGame();
    };

    function startGame() {
      document.getElementById('auth').style.display = 'none';
      document.getElementById('game-container').style.display = 'block';
      initSocket();
      initGameLoop();
    }

    function initSocket() {
      socket = io(SERVER_URL, { auth:{ token } });
      socket.on('connect_error', err => statusEl.textContent = 'Erro: '+err.message);
      socket.on('connect', () => statusEl.textContent = 'Conectado como '+socket.id);
      socket.on('playerMoved', ({id, x:px, y:py}) => otherPlayers[id]={x:px,y:py});
      socket.on('playerDisconnected', id => delete otherPlayers[id]);
    }

    // resto do código (física, desenho, etc.) permanece igual
    const cols = 4, rows = 3;
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const cellWidth = canvas.width / cols;
    const cellHeight = canvas.height / rows;
    let zoomLevel = 1, camX = 0, camY = 0;
    const gravityMap = [ [1,1,1,1],[1,-1,1,1],[1,1,1,-1] ];
    let x = cellWidth/2, y = canvas.height - 20, vx=0, vy=0, onGround=false;
    const speed=5, baseGravity=0.5, jumpStrength=12;
    const otherPlayers = {};
    const statusEl = document.getElementById('status');
    document.addEventListener('keydown', e=>{ if(e.key==='a') vx=-speed; if(e.key==='d') vx=speed; if(e.key===' '&&onGround) vy=-jumpStrength; if(e.key==='1') zoomLevel=1; if(e.key==='2') zoomLevel=2; });
    document.addEventListener('keyup', e=>{ if(e.key==='a'||e.key==='d') vx=0; });

    function getCurrentGravity(){ const col=Math.floor(x/cellWidth), row=Math.floor(y/cellHeight); if(row>=0&&row<rows&&col>=0&&col<cols) return baseGravity*gravityMap[row][col]; return baseGravity; }
    function update(){ vy+=getCurrentGravity(); x+=vx; y+=vy; if(y>=canvas.height-20){ y=canvas.height-20; vy=0; onGround=true;} else onGround=false; if(y<20){ y=20; vy=0;} if(x<20)x=20; if(x>canvas.width-20)x=canvas.width-20; socket.emit('move',{x,y}); }
    function draw(){ if(zoomLevel===2){ const col=Math.floor(x/cellWidth), row=Math.floor(y/cellHeight); const targetX=col*cellWidth, targetY=row*cellHeight; camX+=(targetX-camX)*0.1; camY+=(targetY-camY)*0.1;} ctx.save(); if(zoomLevel===1) ctx.setTransform(1,0,0,1,0,0); else { const sx=canvas.width/cellWidth, sy=canvas.height/cellHeight; ctx.setTransform(sx,0,0,sy,-camX*sx,-camY*sy);} ctx.clearRect(0,0,canvas.width,canvas.height); ctx.strokeStyle='green'; for(let i=0;i<=cols;i++){ ctx.beginPath(); ctx.moveTo(i*cellWidth,0); ctx.lineTo(i*cellWidth,rows*cellHeight); ctx.stroke(); } for(let j=0;j<=rows;j++){ ctx.beginPath(); ctx.moveTo(0,j*cellHeight); ctx.lineTo(cols*cellWidth,j*cellHeight); ctx.stroke(); } ctx.fillStyle='red'; ctx.fillRect(x-10,y-10,20,20); ctx.fillStyle='green'; for(const id in otherPlayers){ const p=otherPlayers[id]; ctx.fillRect(p.x-10,p.y-10,20,20);} ctx.restore(); }
    function initGameLoop(){ setInterval(()=>{ update(); draw(); },1000/30);}  
  </script>
</body>
</html>
